#!/usr/bin/env python3
# Generated by Cursor
"""
交互式 CLI 工具，用于从 cookiecutter 模板创建 Swift Package。

用法:
    python create_project.py                    # 交互模式
    python create_project.py --name MyPackage   # 带参数模式
"""

import argparse
import os
import subprocess
import sys
from pathlib import Path
from typing import Optional, Union

try:
    import questionary
    from questionary import Style
    from rich.console import Console
    from rich.panel import Panel
    from rich.text import Text
    from cookiecutter.main import cookiecutter
except ImportError:
    print("缺少依赖。请执行: pip install -r requirements.txt")
    sys.exit(1)


console = Console()

# 自定义 questionary 样式：高亮背景显示选中项
CUSTOM_STYLE = Style([
    ("qmark", "fg:cyan bold"),             # 问号
    ("question", "bold"),                  # 问题文本
    ("answer", "fg:cyan bold"),            # 已回答的值
    ("pointer", "fg:black bg:cyan bold"),  # 指针（与高亮一致）
    ("highlighted", "fg:black bg:cyan"),   # 高亮选中项
    ("selected", "fg:cyan"),               # 已选择的复选框项
    ("text", ""),                          # 普通文本
    ("instruction", "fg:gray"),            # 指令提示
])

# 模板目录 (cli 文件夹的父目录)
TEMPLATE_DIR = Path(__file__).parent.parent.absolute()

# 平台选项
PLATFORM_CHOICES = ["iOS", "macOS", "iOS and macOS"]


def print_banner() -> None:
    """打印欢迎横幅。"""
    banner = Text()
    banner.append("Swift Package 生成器\n", style="bold cyan")
    banner.append("支持 iOS / macOS 平台\n", style="dim")
    banner.append("Swift Testing + SPM", style="dim italic")
    console.print(Panel(banner, border_style="cyan"))


def select_folder_with_finder() -> Optional[str]:
    """使用 Finder 选择文件夹 (仅 macOS)。"""
    try:
        script = '''
        tell application "Finder"
            activate
        end tell
        set selectedFolder to choose folder with prompt "选择项目输出目录"
        return POSIX path of selectedFolder
        '''
        result = subprocess.run(
            ["osascript", "-e", script],
            capture_output=True,
            text=True,
        )
        if result.returncode == 0:
            return result.stdout.strip()
        return None
    except Exception:
        return None


def validate_package_name(name: str) -> Union[bool, str]:
    """验证 Package 名称。"""
    if not name:
        return "Package 名称不能为空"
    if not name[0].isalpha():
        return "Package 名称必须以字母开头"
    if not all(c.isalnum() or c == "_" for c in name):
        return "Package 名称只能包含字母、数字和下划线"
    return True


def interactive_prompt() -> tuple:
    """运行交互式提示，收集项目配置。返回 (config_dict, output_dir)。"""
    console.print("\n[bold]Package 配置[/bold]\n")

    # Package 名称
    package_name = questionary.text(
        "Package 名称:",
        default="MyPackage",
        validate=validate_package_name,
    ).ask()
    if not package_name:
        sys.exit(0)

    # 作者名称
    author_name = questionary.text(
        "作者/组织名称:",
        default="Developer",
    ).ask()
    if not author_name:
        sys.exit(0)

    console.print("\n[bold]平台选择[/bold]\n")

    # 平台选择（iOS 和 macOS 在前作为默认）
    platforms = questionary.select(
        "目标平台:",
        choices=[
            questionary.Choice("iOS 和 macOS (通用)", value="iOS and macOS"),
            questionary.Choice("iOS", value="iOS"),
            questionary.Choice("macOS", value="macOS"),
        ],
        style=CUSTOM_STYLE,
    ).ask()
    if not platforms:
        sys.exit(0)

    # 部署目标版本
    ios_target = "17.0"
    macos_target = "14.0"
    
    if platforms in ["iOS", "iOS and macOS"]:
        ios_target = questionary.text(
            "iOS 最低部署版本:",
            default="17.0",
        ).ask()
        if not ios_target:
            sys.exit(0)
    
    if platforms in ["macOS", "iOS and macOS"]:
        macos_target = questionary.text(
            "macOS 最低部署版本:",
            default="14.0",
        ).ask()
        if not macos_target:
            sys.exit(0)

    console.print("\n[bold]可选模块[/bold]\n")

    # UI 模块
    include_ui = questionary.confirm(
        "包含 SwiftUI 组件?",
        default=False,
    ).ask()
    if include_ui is None:
        sys.exit(0)

    console.print("\n[bold]输出位置[/bold]\n")

    # 输出目录选择（当前目录在前作为默认）
    output_dir = None
    output_choice = questionary.select(
        "项目输出目录:",
        choices=[
            questionary.Choice(f"当前目录 ({os.getcwd()})", value="cwd"),
            questionary.Choice("通过 Finder 选择...", value="finder"),
            questionary.Choice("手动输入路径", value="manual"),
        ],
        style=CUSTOM_STYLE,
    ).ask()
    if not output_choice:
        sys.exit(0)

    if output_choice == "finder":
        console.print("[dim]正在打开 Finder...[/dim]")
        output_dir = select_folder_with_finder()
        if output_dir:
            console.print(f"[green]已选择:[/green] {output_dir}")
        else:
            console.print("[yellow]未选择目录，使用当前目录[/yellow]")
            output_dir = os.getcwd()
    elif output_choice == "manual":
        output_dir = questionary.path(
            "输入目录路径:",
            default=os.getcwd(),
            only_directories=True,
        ).ask()
        if not output_dir:
            output_dir = os.getcwd()
    else:
        output_dir = os.getcwd()

    config = {
        "package_name": package_name,
        "author_name": author_name,
        "platforms": platforms,
        "ios_deployment_target": ios_target,
        "macos_deployment_target": macos_target,
        "include_ui": "yes" if include_ui else "no",
    }

    return config, output_dir


def create_project(
    output_dir: Optional[str] = None,
    extra_context: Optional[dict] = None,
    no_input: bool = False,
) -> str:
    """从模板创建项目。"""
    output_dir = output_dir or os.getcwd()

    result = cookiecutter(
        str(TEMPLATE_DIR),
        output_dir=output_dir,
        extra_context=extra_context,
        no_input=no_input,
    )

    return result


def main() -> None:
    """主入口。"""
    parser = argparse.ArgumentParser(
        description="从模板创建 Swift Package"
    )
    parser.add_argument(
        "--name",
        "-n",
        help="Package 名称",
    )
    parser.add_argument(
        "--author",
        "-a",
        help="作者/组织名称",
    )
    parser.add_argument(
        "--output-dir",
        "-o",
        help="输出目录 (默认: 当前目录)",
    )
    parser.add_argument(
        "--platforms",
        "-p",
        choices=PLATFORM_CHOICES,
        default="iOS and macOS",
        help="目标平台 (默认: iOS and macOS)",
    )
    parser.add_argument(
        "--ios-target",
        default="17.0",
        help="iOS 最低部署版本 (默认: 17.0)",
    )
    parser.add_argument(
        "--macos-target",
        default="14.0",
        help="macOS 最低部署版本 (默认: 14.0)",
    )
    parser.add_argument(
        "--with-ui",
        action="store_true",
        help="包含 SwiftUI 组件",
    )
    parser.add_argument(
        "--non-interactive",
        action="store_true",
        help="非交互模式运行 (需要 --name)",
    )

    args = parser.parse_args()

    print_banner()

    if args.non_interactive:
        if not args.name:
            console.print("[red]错误: 非交互模式需要 --name 参数[/red]")
            sys.exit(1)

        extra_context = {
            "package_name": args.name,
            "author_name": args.author or "Developer",
            "platforms": args.platforms,
            "ios_deployment_target": args.ios_target,
            "macos_deployment_target": args.macos_target,
            "include_ui": "yes" if args.with_ui else "no",
        }
        output_dir = args.output_dir
    else:
        extra_context, output_dir = interactive_prompt()
        # 命令行参数优先级高于交互式选择
        if args.output_dir:
            output_dir = args.output_dir

    console.print("\n[bold]正在生成 Package...[/bold]\n")

    # 预计的项目路径，用于失败时清理
    output_dir = output_dir or os.getcwd()
    expected_path = os.path.join(output_dir, extra_context["package_name"])

    try:
        project_path = create_project(
            output_dir=output_dir,
            extra_context=extra_context,
            no_input=True,
        )
        console.print(f"\n[green]Package 创建成功:[/green] {project_path}")
    except Exception as e:
        import shutil
        console.print(f"\n[red]创建 Package 失败:[/red] {e}")
        # 清理失败的项目目录
        if os.path.exists(expected_path):
            shutil.rmtree(expected_path)
            console.print(f"\n[yellow]已清理:[/yellow] {expected_path}")
        sys.exit(1)


if __name__ == "__main__":
    main()

