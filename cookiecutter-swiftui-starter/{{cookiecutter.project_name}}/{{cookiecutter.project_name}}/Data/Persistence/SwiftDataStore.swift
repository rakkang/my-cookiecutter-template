// Generated by Cursor
import Foundation
import SwiftData

// MARK: - SwiftData Store Protocol

@MainActor
protocol SwiftDataStoreProtocol: Sendable {
    func fetch<T: PersistentModel>(_ type: T.Type, predicate: Predicate<T>?, sortBy: [SortDescriptor<T>]) throws -> [T]
    func insert<T: PersistentModel>(_ model: T) throws
    func delete<T: PersistentModel>(_ model: T) throws
    func save() throws
}

// MARK: - SwiftData Store

@MainActor
final class SwiftDataStore: SwiftDataStoreProtocol {
    private let modelContext: ModelContext
    
    init(modelContext: ModelContext) {
        self.modelContext = modelContext
    }
    
    convenience init() {
        // Fallback initializer - should use injected context in production
        let container = try! ModelContainer(for: Schema([]))
        self.init(modelContext: container.mainContext)
    }
    
    func fetch<T: PersistentModel>(
        _ type: T.Type,
        predicate: Predicate<T>? = nil,
        sortBy: [SortDescriptor<T>] = []
    ) throws -> [T] {
        let descriptor = FetchDescriptor<T>(predicate: predicate, sortBy: sortBy)
        return try modelContext.fetch(descriptor)
    }
    
    func insert<T: PersistentModel>(_ model: T) throws {
        modelContext.insert(model)
        try save()
    }
    
    func delete<T: PersistentModel>(_ model: T) throws {
        modelContext.delete(model)
        try save()
    }
    
    func save() throws {
        if modelContext.hasChanges {
            try modelContext.save()
        }
    }
}

{% if cookiecutter.include_icloud == 'yes' %}
// MARK: - CloudKit Configuration

extension ModelConfiguration {
    /// Creates a CloudKit-enabled configuration
    static func cloudKitEnabled(
        for schema: Schema,
        cloudKitContainerIdentifier: String? = nil
    ) -> ModelConfiguration {
        ModelConfiguration(
            schema: schema,
            cloudKitDatabase: cloudKitContainerIdentifier.map { .private($0) } ?? .automatic
        )
    }
}
{% endif %}

