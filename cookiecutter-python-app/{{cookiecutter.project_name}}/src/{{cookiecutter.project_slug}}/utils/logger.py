"""Generated by Cursor"""

import logging
import logging.handlers
import os
from pathlib import Path
from typing import Dict, Any, Optional, List

# 存储当前日志配置
_LOGGER_CONFIGURED = False
_CURRENT_CONFIG: Dict[str, Any] = {
    "log_level": "INFO",
    "log_dir": "logs",
    "app_name": "app" 
}

def setup_logger(
    log_level: str = "INFO",
    log_dir: str = "logs",
    app_name: str = "app",
    force_reconfigure: bool = False,
    console_exclude_loggers: Optional[List[str]] = None,
) -> None:
    """
    配置全局日志
    
    Args:
        log_level: 日志级别，默认INFO
        log_dir: 日志文件目录，默认logs
        app_name: 应用名称，默认app
        force_reconfigure: 是否强制重新配置，默认False
        console_exclude_loggers: 控制台中需要隐藏的日志器名（前缀），默认隐藏 httpx/httpcore
    """
    global _LOGGER_CONFIGURED, _CURRENT_CONFIG
    
    # 默认隐藏 noisy 三方库的 INFO 日志
    if console_exclude_loggers is None:
        console_exclude_loggers = ["httpx", "httpcore"]
    
    # 避免重复配置，除非强制重新配置
    if _LOGGER_CONFIGURED and not force_reconfigure:
        # 如果已经配置过，只在日志级别变化时更新级别
        if _CURRENT_CONFIG["log_level"] != log_level:
            root_logger = logging.getLogger()
            root_logger.setLevel(log_level)
            _CURRENT_CONFIG["log_level"] = log_level
        return
    
    # 更新当前配置
    _CURRENT_CONFIG = {
        "log_level": log_level,
        "log_dir": log_dir,
        "app_name": app_name
    }
    
    # 创建日志目录
    log_path = Path(log_dir)
    log_path.mkdir(parents=True, exist_ok=True)
    
    # 日志格式
    log_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - [%(filename)s:%(lineno)d] - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # 获取根日志记录器
    root_logger = logging.getLogger()
    
    # 设置日志级别
    level_num = getattr(logging, log_level.upper(), None)
    if not isinstance(level_num, int):
        level_num = logging.INFO
    root_logger.setLevel(level_num)
    
    # 清除现有的处理器
    root_logger.handlers.clear()
    
    # 控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_format)
    
    class _ExcludeLoggerNamesFilter(logging.Filter):
        """Generated by Cursor
        过滤指定名称前缀的日志（仅用于控制台）
        """
        def __init__(self, names: List[str]):
            super().__init__()
            self._names = tuple(names)
        def filter(self, record: logging.LogRecord) -> bool:
            name = record.name
            # 以这些名前缀开头的日志将被控制台忽略
            return not name.startswith(self._names)
    
    # 仅在控制台中排除 noisy 日志
    if console_exclude_loggers:
        console_handler.addFilter(_ExcludeLoggerNamesFilter(console_exclude_loggers))
    root_logger.addHandler(console_handler)
    
    # 文件处理器 - 常规日志
    file_handler = logging.handlers.TimedRotatingFileHandler(
        filename=os.path.join(log_dir, f"{app_name}.log"),
        when='midnight',
        interval=1,
        backupCount=30,
        encoding='utf-8'
    )
    file_handler.setFormatter(log_format)
    root_logger.addHandler(file_handler)
    
    # 文件处理器 - 错误日志
    error_handler = logging.handlers.TimedRotatingFileHandler(
        filename=os.path.join(log_dir, f"{app_name}_error.log"),
        when='midnight',
        interval=1,
        backupCount=30,
        encoding='utf-8'
    )
    error_handler.setLevel(logging.ERROR)
    error_handler.setFormatter(log_format)
    root_logger.addHandler(error_handler)
    
    # 降低三方库噪音日志级别（依然写入文件，但默认不在控制台显示）
    for noisy_name in console_exclude_loggers or []:
        noisy_logger = logging.getLogger(noisy_name)
        noisy_logger.setLevel(logging.WARNING)
        # 不阻断传递，保留到文件；若需要彻底禁用可将 propagate=False
        # noisy_logger.propagate = False
    
    # 标记为已配置
    _LOGGER_CONFIGURED = True
    
def get_logger(name: Optional[str] = None) -> logging.Logger:
    """
    获取指定名称的日志记录器
    
    Args:
        name: 日志记录器名称，默认为None，表示获取根日志记录器
        
    Returns:
        日志记录器实例
    """
    if not _LOGGER_CONFIGURED:
        setup_logger(**_CURRENT_CONFIG)
    
    if name is None:
        return logging.getLogger()
    return logging.getLogger(name)

# 默认日志配置
setup_logger()

# 导出logger以便其他模块使用
logger = get_logger(__name__)
